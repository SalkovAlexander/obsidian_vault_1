---
tags: []
alliaces: []
---
2023-04-05
21:50
***
###### Tags: #учеба #развитие 
***
# Шо-то по проге на C шарп
***
## Подписка на событие
Подписка на событие в C# - это механизм, который позволяет связать обработчик события (функцию или метод), который будет вызываться при возникновении определенного события.
```csharp
using System;

class Program
{
    static void Main(string[] args)
    {
        // Создаем объект, генерирующий событие
        Button button = new Button();
        
        // Подписываемся на событие Click
        button.Click += OnButtonClick;
        
        // Инициируем событие Click
        button.DoClick();
    }

    // Метод-обработчик события Click
    static void OnButtonClick(object sender, EventArgs e)
    {
        Console.WriteLine("Кнопка была нажата");
    }
}

// Класс, генерирующий событие
class Button
{
    // Объявляем событие Click
    public event EventHandler Click;

    // Метод, который инициирует событие Click
    public void DoClick()
    {
        // Если есть подписчики на событие Click
        if (Click != null)
        {
            // Вызываем событие Click
            Click(this, EventArgs.Empty);
        }
    }
}

```
В данном примере мы создаем класс `Button`, который содержит событие `Click`. Затем мы создаем объект `Button`, подписываемся на событие `Click` с помощью оператора `+=` и инициируем событие `Click` вызовом метода `DoClick()`. Когда событие `Click` инициируется, вызывается обработчик `OnButtonClick`, который выводит сообщение в консоль.

Обратите внимание на то, что для объявления события мы использовали тип `EventHandler`, который представляет общий шаблон для событий, не имеющих дополнительных параметров. Если вы хотите передавать дополнительные параметры в обработчик события, вы можете объявить свой собственный тип делегата.
## Переопределения метода
```csharp
using System;

class Animal
{
    public virtual void MakeSound()
    {
        Console.WriteLine("The animal makes a sound");
    }
}

class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("The dog barks");
    }
}

class Program
{
    static void Main(string[] args)
    {
        Animal animal = new Animal();
        animal.MakeSound(); // Output: The animal makes a sound

        Dog dog = new Dog();
        dog.MakeSound(); // Output: The dog barks
    }
}
```
Ключевое слово "override" в C# используется для переопределения метода базового класса в производном классе.

Когда производный класс наследует метод от базового класса, он может использовать ключевое слово "override" для переопределения реализации метода. Таким образом, при вызове метода из производного класса будет использоваться его переопределенная реализация, а не реализация из базового класса.

Кроме того, ключевое слово "override" гарантирует, что переопределенный метод имеет точно такую же сигнатуру (типы и порядок параметров) как метод базового класса, что позволяет компилятору C# понимать, что метод должен быть переопределен и проверять правильность переопределения на этапе компиляции.
## Концепции ООП (инкапсуляция, полиморфизм, наследование, абстракция)
### Инкапсуляция
Инкапсуляция - это принцип, который позволяет скрыть внутреннюю реализацию объекта от внешнего мира. Объект должен предоставлять только необходимый интерфейс для работы с ним, а его внутренние детали должны быть скрыты от пользователя. Это делает код более безопасным и удобным в использовании, а также облегчает сопровождение и изменение кода.
### Полиморфизм
Полиморфизм - это принцип, который позволяет объектам с одинаковым интерфейсом работать совершенно по-разному в зависимости от конкретной реализации. То есть, методы с одним и тем же именем и параметрами могут вести себя по-разному в разных классах. Это позволяет создавать более гибкий и масштабируемый код, так как позволяет заменять одни объекты другими без необходимости изменения кода, работающего с ними.
### Наследование
Наследование позволяет создавать новый класс на основе уже существующего класса, который называется базовым классом или родительским классом. Новый класс, который наследует свойства и методы базового класса, называется производным классом или дочерним классом. Дочерний класс может дополнять или изменять функциональность базового класса, а также добавлять свои собственные свойства и методы.

Наследование позволяет повторно использовать код, что упрощает разработку приложений и уменьшает количество ошибок. Кроме того, наследование помогает создавать иерархию классов, что упрощает понимание структуры приложения.
### Абстракция
Абстракция позволяет скрыть детали реализации от пользователя и предоставить только те методы, которые необходимы для работы с объектом. Абстракция достигается с помощью абстрактных классов и интерфейсов.

Абстрактный класс - это класс, который не может быть создан напрямую, а только через его производные классы. Абстрактный класс может содержать абстрактные методы, которые не имеют реализации в самом классе, а только в его производных классах. Абстрактные классы могут использоваться для определения общего интерфейса для группы классов.

Интерфейс - это абстрактный класс, который содержит только абстрактные методы и свойства. Интерфейс определяет общий интерфейс для группы классов, но не содержит реализации. Классы могут реализовывать интерфейсы и таким образом обеспечивать совместимость с другими классами, которые используют тот же интерфейс.
```csharp
using System;

// Определяем абстрактный класс Vehicle
abstract class Vehicle
{
    public string Model { get; set; }
    public int Year { get; set; }
    
    // Определяем абстрактный метод, который должен быть реализован в производных классах
    public abstract void Drive();
}

// Определяем производный класс Car, который наследует класс Vehicle
class Car : Vehicle
{
    // Реализуем абстрактный метод Drive
    public override void Drive()
    {
        Console.WriteLine("Driving a car...");
    }
}

class Program
{
    static void Main(string[] args)
    {
        // Создаем объект класса Car
        Car car = new Car();
        
        // Вызываем метод Drive
        car.Drive();
    }
}

```
## SOLID
Существует 4 основных принципа ООП, которые называют SOLID:

1.  Принцип единственной ответственности (Single Responsibility Principle, SRP): класс должен иметь только одну ответственность.
2.  Принцип открытости/закрытости (Open/Closed Principle, OCP): классы должны быть открыты для расширения, но закрыты для изменения.
3.  Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP): объекты базового класса должны быть способны заменяться на любые его подклассы без нарушения работы программы.
4.  Принцип разделения интерфейса (Interface Segregation Principle, ISP): клиенты не должны зависеть от методов, которые они не используют.

Также существуют дополнительные принципы, такие как принцип инверсии зависимостей (Dependency Inversion Principle, DIP), но они являются расширением первоначальных четырех принципов.
## ^-^
***
###### Zero-Links
- 
***
###### Links
-